// Generated by CoffeeScript 1.3.3
(function() {
  var __slice = [].slice;

  beforeEach(function() {
    return this.addMatchers({
      toHaveData: function(expected) {
        var a, array, arrays, i, j, nFields, p, point, points, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
        points = this.actual.getDataPoints();
        if (points.length !== expected.length) {
          return false;
        }
        for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
          point = points[i];
          for (j = _j = 0, _len1 = point.length; _j < _len1; j = ++_j) {
            p = point[j];
            if (points[i][j] !== expected[i][j]) {
              return false;
            }
          }
        }
        nFields = (_ref = (_ref1 = expected[0]) != null ? _ref1.length : void 0) != null ? _ref : 2;
        arrays = (function() {
          var _k, _results;
          _results = [];
          for (x = _k = 0; 0 <= nFields ? _k < nFields : _k > nFields; x = 0 <= nFields ? ++_k : --_k) {
            _results.push([]);
          }
          return _results;
        })();
        (_ref2 = this.actual).copyDataInto.apply(_ref2, arrays);
        for (i = _k = 0, _len2 = arrays.length; _k < _len2; i = ++_k) {
          array = arrays[i];
          if (array.length !== expected.length) {
            return false;
          }
          for (j = _l = 0, _len3 = array.length; _l < _len3; j = ++_l) {
            a = array[j];
            if (arrays[i][j] !== expected[j][i]) {
              return false;
            }
          }
        }
        return true;
      },
      toHaveLength: function(expected) {
        return this.actual.getLength() === expected;
      }
    });
  });

  describe("ISImporter.Dataset", function() {
    describe("the Dataset class", function() {
      it("should exist", function() {
        return expect(ISImporter.Dataset).toBeDefined();
      });
      return it("should create instances with the new operator", function() {
        return expect(typeof new ISImporter.Dataset()).toBe('object');
      });
    });
    return describe("a Dataset instance", function() {
      var dataset;
      dataset = null;
      beforeEach(function() {
        return dataset = new ISImporter.Dataset();
      });
      describe("when created", function() {
        it("should have length 0", function() {
          return expect(dataset).toHaveLength(0);
        });
        it("should have data []", function() {
          return expect(dataset).toHaveData([]);
        });
        describe("its selection domain", function() {
          return it("should be null", function() {
            return expect(dataset.getSelectionDomain()).toBeNull();
          });
        });
        describe("its next x", function() {
          return it("should be 0", function() {
            return expect(dataset.getNextX()).toBe(0);
          });
        });
        describe("its x increment", function() {
          return it("should be 1", function() {
            return expect(dataset.getXIncrement()).toBe(1);
          });
        });
        return it("should be possible to add data without calling setDataPoints", function() {
          dataset.add(1);
          return expect(dataset).toHaveData([[0, 1]]);
        });
      });
      describe("its setDataPoints method", function() {
        return describe("when called with arguments [1,2] and [3,4]", function() {
          var dataLengthInListener, dataResetSpy;
          dataResetSpy = null;
          dataLengthInListener = null;
          beforeEach(function() {
            dataResetSpy = jasmine.createSpy('dataReset');
            dataset.on('dataReset', function() {
              dataResetSpy();
              return dataLengthInListener = dataset.getDataPoints().length;
            });
            return dataset.setDataPoints([1, 2], [3, 4]);
          });
          it("should set the data to [[1,2], [3,4]]", function() {
            return expect(dataset).toHaveData([[1, 2], [3, 4]]);
          });
          it("should fire the 'dataReset' event", function() {
            return expect(dataResetSpy).toHaveBeenCalled();
          });
          return describe("at the time the dataReset handler is called", function() {
            return it("should already have updated the dataset's data", function() {
              return expect(dataLengthInListener).toBe(2);
            });
          });
        });
      });
      describe("when initialized with data [[1,2], [3,4]]", function() {
        beforeEach(function() {
          return dataset.setDataPoints([1, 2], [3, 4]);
        });
        it("should have length 2", function() {
          return expect(dataset).toHaveLength(2);
        });
        return describe("and x increment is set to 2", function() {
          beforeEach(function() {
            return dataset.setXIncrement(2);
          });
          return describe("and next x is set to 5", function() {
            beforeEach(function() {
              return dataset.setNextX(5);
            });
            return describe("after a datapoint is added by calling add(6)", function() {
              var dataLengthInListener, dataResetSpy, dataSpy;
              dataSpy = null;
              dataResetSpy = null;
              dataLengthInListener = null;
              beforeEach(function() {
                dataSpy = jasmine.createSpy('data');
                dataset.on('data', function() {
                  var args;
                  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                  dataSpy.apply(null, args);
                  return dataLengthInListener = dataset.getDataPoints().length;
                });
                dataResetSpy = jasmine.createSpy('dataReset');
                dataset.on('dataReset', dataResetSpy);
                return dataset.add(6);
              });
              it("should now have the point [5, 6]", function() {
                return expect(dataset).toHaveData([[1, 2], [3, 4], [5, 6]]);
              });
              it("should have length 3", function() {
                return expect(dataset).toHaveLength(3);
              });
              describe("its next x", function() {
                return it("should be 7", function() {
                  return expect(dataset.getNextX()).toBe(7);
                });
              });
              it("should not fire the 'dataReset' event", function() {
                return expect(dataResetSpy).not.toHaveBeenCalled();
              });
              it("should fire the 'data' event", function() {
                return expect(dataSpy).toHaveBeenCalled();
              });
              describe("the 'data' event handler", function() {
                it("should be called with the new data value [5, 6]", function() {
                  return expect(dataSpy).toHaveBeenCalledWith([5, 6]);
                });
                return it("should be called after the dataset has been updated with the new data", function() {
                  return expect(dataLengthInListener).toBe(3);
                });
              });
              return describe("and another datapoint is added by calling add(8)", function() {
                beforeEach(function() {
                  return dataset.add(8);
                });
                return it("should respect the updated next x value of 7", function() {
                  return expect(dataset).toHaveData([[1, 2], [3, 4], [5, 6], [7, 8]]);
                });
              });
            });
          });
        });
      });
      describe("its copyDataInto method", function() {
        return describe("when it is passed two nonempty arrays, 'x' and 'y'", function() {
          var x, y;
          x = null;
          y = null;
          beforeEach(function() {
            x = ['stuff'];
            return y = ['additional', 'stuff'];
          });
          describe("and the data is []", function() {
            beforeEach(function() {
              dataset.setDataPoints();
              return dataset.copyDataInto(x, y);
            });
            it("should set the first array to []", function() {
              return expect(x).toEqual([]);
            });
            return it("should set the second array to []", function() {
              return expect(y).toEqual([]);
            });
          });
          return describe("and the data is [[1,2], [3,4]]", function() {
            beforeEach(function() {
              dataset.setDataPoints([1, 2], [3, 4]);
              return dataset.copyDataInto(x, y);
            });
            it("should set the first, 'x' array to [1,3]", function() {
              return expect(x).toEqual([1, 3]);
            });
            return it("should set the second, 'y' array to [2,4]", function() {
              return expect(y).toEqual([2, 4]);
            });
          });
        });
      });
      describe("its getDataPoints method", function() {
        describe("when the data is []", function() {
          beforeEach(function() {
            return dataset.setDataPoints();
          });
          return it("should return []", function() {
            return expect(dataset.getDataPoints()).toEqual([]);
          });
        });
        return describe("when the data is [[1,2], [3,4]]", function() {
          beforeEach(function() {
            return dataset.setDataPoints([1, 2], [3, 4]);
          });
          return it("should return [[1,2], [3,4]]", function() {
            return expect(dataset.getDataPoints()).toEqual([[1, 2], [3, 4]]);
          });
        });
      });
      describe("copying behavior", function() {
        return describe("when setDataPoints is called with [1,2]", function() {
          var p1;
          p1 = null;
          beforeEach(function() {
            p1 = [1, 2];
            return dataset.setDataPoints(p1);
          });
          return describe("and the datapoint is subsequently mutated", function() {
            beforeEach(function() {
              return p1[0] = 5;
            });
            return it("should not change the data in the dataset", function() {
              expect(p1).toEqual([5, 2]);
              return expect(dataset).toHaveData([[1, 2]]);
            });
          });
        });
      });
      return describe("selection support", function() {
        return describe("when data is [[1,2], [3,4], [5,6], [7, 8]", function() {
          beforeEach(function() {
            return dataset.setDataPoints([1, 2], [3, 4], [5, 6], [7, 8]);
          });
          describe("after selecting null", function() {
            beforeEach(function() {
              return dataset.select(null);
            });
            describe("the selection domain", function() {
              return it("should be null", function() {
                return expect(dataset.getSelectionDomain()).toBeNull();
              });
            });
            return describe("the selected data", function() {
              return it("should be null", function() {
                return expect(dataset.getSelectedDataPoints()).toBeNull();
              });
            });
          });
          describe("after selecting []", function() {
            beforeEach(function() {
              return dataset.select([]);
            });
            describe("the selection domain", function() {
              return it("should be []", function() {
                return expect(dataset.getSelectionDomain()).toEqual([]);
              });
            });
            return describe("the selected data", function() {
              return it("should be []", function() {
                return expect(dataset.getSelectedDataPoints()).toEqual([]);
              });
            });
          });
          return describe("after selecting the region [2,6]", function() {
            beforeEach(function() {
              return dataset.select([2, 6]);
            });
            describe("the selection domain", function() {
              return it("should be [2, 6]", function() {
                return expect(dataset.getSelectionDomain()).toEqual([2, 6]);
              });
            });
            describe("the selected data", function() {
              return it("should be [[3,4], [5,6]]", function() {
                return expect(dataset.getSelectedDataPoints()).toEqual([[3, 4], [5, 6]]);
              });
            });
            describe("when the selection domain lower boundary equals a data point x value (select([1,6]))", function() {
              beforeEach(function() {
                return dataset.select([1, 6]);
              });
              return describe("the selected data", function() {
                return it("should include the intersecting point ([1,2])", function() {
                  return expect(dataset.getSelectedDataPoints()).toEqual([[1, 2], [3, 4], [5, 6]]);
                });
              });
            });
            describe("when the selection domain upper boundary equals a data point x value (select([2,7]))", function() {
              beforeEach(function() {
                return dataset.select([2, 7]);
              });
              return describe("the selected data", function() {
                return it("should include the intersecting point ([7, 8])", function() {
                  return expect(dataset.getSelectedDataPoints()).toEqual([[3, 4], [5, 6], [7, 8]]);
                });
              });
            });
            return describe("when the select method is called with [xmax, xmin] with xmax > xmin: select([6,2])", function() {
              beforeEach(function() {
                return dataset.select([6, 2]);
              });
              describe("the selection domain", function() {
                return it("should be reported as [xmin, xmax]", function() {
                  return expect(dataset.getSelectionDomain()).toEqual([2, 6]);
                });
              });
              return describe("the selected data", function() {
                return it("should still contain the data with x values between xmin and xmax", function() {
                  return expect(dataset.getSelectedDataPoints()).toEqual([[3, 4], [5, 6]]);
                });
              });
            });
          });
        });
      });
    });
  });

}).call(this);
