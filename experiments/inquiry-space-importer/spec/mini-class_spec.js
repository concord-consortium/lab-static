// Generated by CoffeeScript 1.3.3
(function() {

  describe("mini-class.js", function() {
    describe("defineClass function", function() {
      var ClassA;
      ClassA = null;
      beforeEach(function() {
        return ClassA = defineClass({
          getClassName: function() {
            return this.className;
          },
          className: "ClassA",
          extraProperty: "ClassA definition of 'extraProperty'"
        });
      });
      it("should return a constructor function", function() {
        return expect(typeof ClassA).toBe('function');
      });
      return describe("an instance created by calling new", function() {
        var objA;
        objA = null;
        describe("when no arguments are passed to the constructor", function() {
          beforeEach(function() {
            return objA = new ClassA();
          });
          return it("should implement methods and properties defined in the class", function() {
            return expect(objA.getClassName()).toBe(objA.className);
          });
        });
        describe("when arguments are passed to the constructor", function() {
          beforeEach(function() {
            return objA = new ClassA({
              objAProperty: "property defined in objA's constructor argument"
            });
          });
          it("should implement the property defined in the constructor argument", function() {
            return expect(objA.objAProperty).toBe("property defined in objA's constructor argument");
          });
          return it("should still implement properties and methods defined in the class", function() {
            return expect(objA.getClassName()).toBe(objA.className);
          });
        });
        return describe("when arguments passed to the constructor have the same name as properties defined in the class", function() {
          beforeEach(function() {
            return objA = new ClassA({
              extraProperty: "objA definition of 'extraProperty'"
            });
          });
          return it("should override the property defined in the class", function() {
            return expect(objA.extraProperty).toBe("objA definition of 'extraProperty'");
          });
        });
      });
    });
    return describe("extendClass function", function() {
      var ClassA, ClassB;
      ClassA = null;
      ClassB = null;
      beforeEach(function() {
        ClassA = defineClass({
          getClassName: function() {
            return this.className;
          },
          className: "ClassA",
          extraProperty: "ClassA definition of 'extraProperty'"
        });
        ClassA.classProperty = "classProperty defined directly on classA";
        return ClassB = extendClass(ClassA, {
          getClassName: function() {
            return this.className + " which extends " + this.constructor.__super__.className;
          },
          className: "ClassB"
        });
      });
      it("should return a constructor function", function() {
        return expect(typeof ClassB).toBe('function');
      });
      describe("the constructor function", function() {
        it("should be annotated with a reference to the superclass implementation", function() {
          return expect(ClassB.__super__).toEqual(ClassA.prototype);
        });
        return it("should have a copy of the 'class properties' defined on the parent constructor function", function() {
          return expect(ClassB.classProperty).toEqual("classProperty defined directly on classA");
        });
      });
      return describe("a child class instance created by calling new", function() {
        var objB;
        objB = null;
        beforeEach(function() {
          return objB = new ClassB();
        });
        it("should retain the parent class value of a property the child class does not override", function() {
          return expect(objB.extraProperty).toBe("ClassA definition of 'extraProperty'");
        });
        it("should have the child class value of a property the child class does override", function() {
          return expect(objB.className).toBe("ClassB");
        });
        return it("should provide a mechanism for child class methods to access superclass values of overridden properties", function() {
          return expect(objB.getClassName()).toBe("ClassB which extends ClassA");
        });
      });
    });
  });

}).call(this);
