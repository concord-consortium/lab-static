// Generated by CoffeeScript 1.3.3
(function() {

  describe("VernierSensorApplet class", function() {
    var applet;
    applet = null;
    beforeEach(function() {
      return applet = new ISImporter.VernierSensorApplet();
    });
    it("should exist", function() {
      return expect(applet).toBeDefined();
    });
    it("should be a subclass of SensorApplet", function() {
      return expect(applet.constructor.__super__).toBe(ISImporter.SensorApplet.prototype);
    });
    describe("getCodebase method", function() {
      describe("given no pathname", function() {
        return it("should return \"/jnlp\"", function() {
          var pathname;
          pathname = null;
          return expect(applet.getCodebase(pathname)).toEqual("/jnlp");
        });
      });
      describe("given a pathname with no prefix: \"/experiments/inquiry-space-importer/\"", function() {
        return it("should return \"/jnlp\"", function() {
          var pathname;
          pathname = null;
          return expect(applet.getCodebase(pathname)).toEqual("/jnlp");
        });
      });
      return describe("given a pathname with a prefix: \"/DataGames/Games/concord/lab.dev/experiments/inquiry-space-importer/\"", function() {
        return it("should return the prefix (\"/DataGames/Games/concord/lab.dev\")  plus \"/jnlp\"", function() {
          var pathname;
          pathname = "/DataGames/Games/concord/lab.dev/experiments/inquiry-space-importer/";
          return expect(applet.getCodebase(pathname)).toEqual("/DataGames/Games/concord/lab.dev/jnlp");
        });
      });
    });
    describe("when instance properties are set appropriately", function() {
      beforeEach(function() {
        applet.listenerPath = '(dummy listener path)';
        applet.sensorType = '(dummy sensor type)';
        applet.deviceType = '(dummy device type)';
        return applet.deviceSpecificJarUrls = ['dummy-device-specific-jar1.jar', 'dummy-device-specific-jar2.jar'];
      });
      describe("getHTML method", function() {
        return it("should construct the appropriate applet tag", function() {
          return expect(applet.getHTML()).toBe(['<applet ', 'id="sensor-applet" ', 'class="applet sensor-applet" ', 'archive="com/sun/jna/jna.jar, ', 'org/concord/sensor/sensor.jar, ', 'org/concord/sensor/sensor-vernier/sensor-vernier.jar, ', 'org/concord/sensor/sensor-applets/sensor-applets.jar, ', 'dummy-device-specific-jar1.jar, ', 'dummy-device-specific-jar2.jar" ', 'code="org.concord.sensor.applet.SensorApplet" ', 'codebase="/jnlp" ', 'width="1px" ', 'height="1px" ', 'MAYSCRIPT="true" >', '<param name="MAYSCRIPT" value="true" />', '</applet>'].join(''));
        });
      });
      return describe("testAppletReady method", function() {
        beforeEach(function() {
          applet.appletInstance = {
            getSensorRequest: function() {},
            initSensorInterface: function() {}
          };
          spyOn(applet.appletInstance, 'getSensorRequest').andReturn('(new SensorRequest)');
          return spyOn(applet.appletInstance, 'initSensorInterface');
        });
        it("should pass the sensorType to the getSensorRequest method of the applet instance", function() {
          applet.testAppletReady();
          return expect(applet.appletInstance.getSensorRequest).toHaveBeenCalledWith('(dummy sensor type)');
        });
        it("should pass the listenerPath to the initSensorInterface method of the applet instance", function() {
          applet.testAppletReady();
          return expect(applet.appletInstance.initSensorInterface).toHaveBeenCalledWith('(dummy listener path)', '(dummy device type)', ['(new SensorRequest)']);
        });
        describe("if getSensorRequest does not throw an error", function() {
          return it("should return true", function() {
            return expect(applet.testAppletReady()).toBe(true);
          });
        });
        return describe("if getSensorRequest throws an error", function() {
          beforeEach(function() {
            return applet.appletInstance.getSensorRequest.andThrow(new Error());
          });
          return it("should return false", function() {
            return expect(applet.testAppletReady()).toBe(false);
          });
        });
      });
    });
    describe("sensorsReady applet callback", function() {
      it("should call sensorIsReady parent method", function() {
        spyOn(applet, 'sensorIsReady');
        applet.sensorsReady();
        return expect(applet.sensorIsReady).toHaveBeenCalled();
      });
      describe("return value of getIsInAppletCallback method", function() {
        return describe("during sensorIsReady method", function() {
          var returnValueDuring;
          returnValueDuring = null;
          beforeEach(function() {
            returnValueDuring = null;
            return spyOn(applet, 'sensorIsReady').andCallFake(function() {
              return returnValueDuring = applet.getIsInAppletCallback();
            });
          });
          return it("should be true", function() {
            applet.sensorsReady();
            return expect(returnValueDuring).toBe(true);
          });
        });
      });
      return describe("after sensorsReady returns", function() {
        return it("should be false", function() {
          applet.sensorsReady();
          return expect(applet.getIsInAppletCallback()).toBe(false);
        });
      });
    });
    describe("The dataReceived applet callback", function() {
      var dataCb;
      dataCb = null;
      beforeEach(function() {
        dataCb = jasmine.createSpy('dataCb');
        return applet.on('data', dataCb);
      });
      it("should emit the 'data' event", function() {
        applet.dataReceived(null, 1, [1.0]);
        return expect(dataCb).toHaveBeenCalled();
      });
      describe("the data callback", function() {
        it("should be called while getIsInAppletCallback() returns true", function() {
          var wasIn;
          wasIn = null;
          dataCb.andCallFake(function() {
            return wasIn = applet.getIsInAppletCallback();
          });
          applet.dataReceived(null, 1, [1.0]);
          return expect(wasIn).toBe(true);
        });
        describe("when dataReceived is sent an array with a single datum", function() {
          return it("should be called with the datum received from the applet callback", function() {
            applet.dataReceived(null, 1, [1.0]);
            return expect(dataCb).toHaveBeenCalledWith(1.0);
          });
        });
        return describe("when dataReceived is sent an array with more than one datum", function() {
          return it("should be called once with each datum", function() {
            applet.dataReceived(null, 2, [1.0, 2.0]);
            expect(dataCb.callCount).toBe(2);
            expect(dataCb.argsForCall[0]).toEqual([1.0]);
            return expect(dataCb.argsForCall[1]).toEqual([2.0]);
          });
        });
      });
      return describe("after dataReceived returns", function() {
        beforeEach(function() {
          return applet.dataReceived();
        });
        return describe("getIsInAppletCallback method", function() {
          return it("should return false", function() {
            return expect(applet.getIsInAppletCallback()).toBe(false);
          });
        });
      });
    });
    describe("The dataStreamEvent applet callback", function() {
      it("should exist and be callable", function() {
        return expect(typeof applet.dataStreamEvent).toBe('function');
      });
      return it("should not throw an error", function() {
        return expect(applet.dataStreamEvent).not.toThrow();
      });
    });
    describe("_stopSensor method", function() {
      beforeEach(function() {
        applet.appletInstance = {
          stopCollecting: function() {}
        };
        return spyOn(applet.appletInstance, 'stopCollecting');
      });
      describe("when called from outside an applet callback", function() {
        return it("should call the applet stopCollecting method", function() {
          applet._stopSensor();
          return expect(applet.appletInstance.stopCollecting).toHaveBeenCalled();
        });
      });
      return describe("when called from within an applet callback", function() {
        beforeEach(function() {
          applet.startAppletCallback();
          return runs(function() {
            return applet._stopSensor();
          });
        });
        describe("immediately", function() {
          return it("should not have called the applet stopCollecting method", function() {
            return runs(function() {
              return expect(applet.appletInstance.stopCollecting).not.toHaveBeenCalled();
            });
          });
        });
        return describe("after waiting", function() {
          beforeEach(function() {
            return waits(100);
          });
          return it("should have called the applet stopCollecting method", function() {
            return runs(function() {
              return expect(applet.appletInstance.stopCollecting).toHaveBeenCalled();
            });
          });
        });
      });
    });
    return describe("_startSensor method", function() {
      beforeEach(function() {
        applet.appletInstance = {
          startCollecting: function() {}
        };
        return spyOn(applet.appletInstance, 'startCollecting');
      });
      describe("when called from outside an applet callback", function() {
        return it("should call the applet startCollecting method", function() {
          applet._startSensor();
          return expect(applet.appletInstance.startCollecting).toHaveBeenCalled();
        });
      });
      return describe("when called from within an applet callback", function() {
        beforeEach(function() {
          applet.startAppletCallback();
          return runs(function() {
            return applet._startSensor();
          });
        });
        describe("immediately", function() {
          return it("should not have called the applet startCollecting method", function() {
            return runs(function() {
              return expect(applet.appletInstance.startCollecting).not.toHaveBeenCalled();
            });
          });
        });
        return describe("after waiting", function() {
          beforeEach(function() {
            return waits(100);
          });
          return it("should have called the applet stopCollecting method", function() {
            return runs(function() {
              return expect(applet.appletInstance.startCollecting).toHaveBeenCalled();
            });
          });
        });
      });
    });
  });

  /*
  
  responsibilities of SensorApplet
  
    # SHOULD THERE BE a division of responsibility between SensorApplet and GoIOApplet?
  
    appends applet tag to DOM
    waits for applet startup
    records start and end of applet callback (should never call applet method within applet callback, apparently)
    removes applet tag from DOM when requested
  reacords lifecycle of applet (not appended, appended, applet ready, sensors ready, removed)
  
  responsibilities of GoIOApplet
    constructs appropriate applet tag
  
  
  
    forwards sensor ready event to callback
    forwards data received events to callback
    forwards metadata events to callback (if ever implemented)
  */


}).call(this);
